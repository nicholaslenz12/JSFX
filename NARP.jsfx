desc:NARP
options:gfx_hz=60

import knobs.jsfx
import shapes.jsfx
import math.jsfx
import defines.jsfx
import data_structures.jsfx

// ----------------------------------------------------------------------------
// SLIDER DEFINITIONS
// ----------------------------------------------------------------------------
slider1:3<0,5,1{1/1,1/2, 1/4, 1/8, 1/16, 1/32}>-Rate (Synced)

// ----------------------------------------------------------------------------
// DEFAULT CHANNEL CONFIGURATION
// ----------------------------------------------------------------------------
in_pin:none
out_pin:none

// ----------------------------------------------------------------------------
// INIT
// ----------------------------------------------------------------------------
@init
gfx_ext_retina = 1;

background.color_create(LIGHTORANGE.r, LIGHTORANGE.g, LIGHTORANGE.b);

knob1.knob_create(1/2, 1/2, 1/5, 0, 5, 3, 1);
knob1.font.font_create(1, "Arial", 0.1); // wrapper around gfx_setfont
knob1.formatter.formatter_create("1/%d", "Power", "");

knob1.colors_shapes.color_create(COFFEE.r, COFFEE.g, COFFEE.b);
knob1.colors.color_create(LIGHTORANGE.r, LIGHTORANGE.g, LIGHTORANGE.b);
knob1.colors_hover.color_create(LIGHTORANGE.r, LIGHTORANGE.g, LIGHTORANGE.b);

length = 0.99;
t_beat = 0;

prev_note_ons = 0;
note_on_count = 1;

note_list = 0; // stores binary for key pressed, native reaper arp uses velocities
current_note_idx = -1;
playing_note = 0;

// ----------------------------------------------------------------------------
// SLIDER
// ----------------------------------------------------------------------------
@slider
knob1.knob_detect_slider();

// ----------------------------------------------------------------------------
// BLOCK
// ----------------------------------------------------------------------------
@block
prev_list_len = note_list.length;
while (midirecv(offset, cmd, note, vel)) (
    cmd == NOTE_ON && vel > 0 ? ( // Add note to the note list
        !note_list.contains(note) ? (
            note_list.push(note);
        );
    ) : (cmd == NOTE_OFF || cmd == NOTE_ON) ? ( // Remove note from note list, (kill note if being played)
        note_list.contains(note) ? (
            midisend(offset, NOTE_OFF, note);
            current_note_idx = -1;
        );
        note_list.remove(note);
    ) : ( // passthrough other events
        midisend(offset, cmd, key, vel);
    );
);

// kill any dangling notes (risk of FLP error?)
note_list.length == 0 && current_note_idx >= 0 ? (
    midisend(0, NOTE_OFF, note_list[current_note_idx]);
    current_note_idx = -1;
);

// can we do this elsewhere?
beat_fraction = 2 ^ -slider(knob1.slider_idx);
cycle_rate = 1/srate * tempo/60 / beat_fraction / 4;
sample_position = 0;

cycle_length = srate * 60/tempo * beat_fraction * 4;

// Just starting, so start playout of next note immediately
note_list.length > 0 && prev_list_len == 0 ? (
    t_beat = cycle_length;
    prev_note_ons = 1;
);

// ----------------------------------------------------------------------------
// SAMPLE
// ----------------------------------------------------------------------------
@sample
t_beat += 1;

note_list.length > 0 && t_beat >= cycle_length && !playing_note ? (
    t_beat -= cycle_length;
    current_note_idx = mod_pos(current_note_idx+1, note_list.length);
    midisend(sample_position, NOTE_ON, note_list[current_note_idx], 127);
    playing_note = 1;
);

note_list.length > 0 && t_beat >= length * cycle_length && playing_note ? (
    midisend(sample_position, NOTE_OFF, note_list[current_note_idx], 127);
    playing_note = 0;
);

sample_position += 1;
// ----------------------------------------------------------------------------
// GRAPHICS
// ----------------------------------------------------------------------------
@gfx 624 395

background.gfx_colors_from_color();
gfx_rect(0, 0, gfx_w, gfx_h);

knob1.knob_draw();
knob1.knob_detect_reset();
knob1.knob_detect_drag();
knob1.knob_update_slider(1);
knob1.knob_draw_arrows();
sliderchange(slider1);

PROG_STATE != GOOD ? (
    gfx_drawstr("BAD BAD BAD!");
);
