desc:Buttons

import colors.jsfx

// TODO:
// - Make reset times independent of framerate
// - RGB color object parameter

@init
// If this is not detected to a slider, you can pass 0 for slider_idx
function button_create(x, y, r, min_val, max_val, init_val, colors, slider_idx) (
    this.x = x;
    this.y = y;
    this.r = r;

    // button_detect_drag
    this.min_val = min_val;
    this.max_val = max_val;
    this.init_val = init_val;
    this.val = init_val; // button keeps track of state? Or should this be elsewhere?
    this.mouse_held = 0;

    // button_detect_reset
    this.clicked_time = 0;
    this.unclicked = 0;
    this.reset_time = 0;
    this.reset = 0;

    this.colors = colors;
    this.slider_idx = slider_idx;
);

// Add "" for label to have no label
// label is used when the button is static
function button_draw(format, label) instance(val) (
    antialias = 1;
    x = gfx_w * this.x;
    y = gfx_h * this.y;
    r = min(gfx_w * this.r, gfx_h * this.r);
    
    set_from_colors(this.colors);
    gfx_circle(x, y, r, 1, antialias);
    black();
    norm = (val - this.min_val) / (this.max_val - this.min_val);
    gfx_rect(x-r, y-r, 2*r, 2*r*(1 - norm));
    white();
    gfx_circle(x, y, r, 0, antialias);
    a = 1;
    b = 2;
    (strlen(label) > 0) && (!this.mouse_held) ? ( // draw label
        gfx_measurestr(label, a, b);
        gfx_x = x - a/2;
        gfx_y = y - b/2;
        gfx_printf("%s", label);
    ) : ( // draw parameter value
        #s = "";
        sprintf(#s, format, val);
        gfx_measurestr(#s, a, b);
        gfx_x = x - a/2;
        gfx_y = y - b/2;
        gfx_printf(format, val);
    );
);

// It's up to external code to change the slider state
// (or add a function that updates the slider state?)
function button_detect_drag() instance(val) (
    x = gfx_w * this.x;
    y = gfx_h * this.y;
    r = min(gfx_w * this.r, gfx_h * this.r);

    in_range = (mouse_x - x)^2 + (mouse_y - y)^2 < r^2;
    mouse_cap == 1 && !this.mouse_held && in_range && !this.reset ? (
        this.mouse_held = 1;
        hold_x = mouse_x;
        hold_y = mouse_y;
        val_    = val;
    );
    !mouse_cap ? (
        this.mouse_held = 0;
    );
    
    this.mouse_held && !this.reset ? (
        delta_norm = (hold_y - mouse_y) / r;
        
        a_inv = 2 / (this.max_val - this.min_val);
        b_inv = -1 * a_inv * this.min_val - 1;
        val_norm = a_inv * val_ + b_inv;

        a = (this.max_val - this.min_val) / 2;
        b = (this.max_val + this.min_val) / 2;
        val = a * (delta_norm + val_norm) + b;

        val = min(val, this.max_val);
        val = max(val, this.min_val);
    );
);

function button_detect_reset() instance(val) (
    x = gfx_w * this.x;
    y = gfx_h * this.y;
    in_range = (mouse_x - x)^2 + (mouse_y - y)^2 < r^2;
    
    in_range ? (
        // starts the clock awaiting second click
        mouse_cap && this.clicked_time == 0 && this.reset_time == 0 ? (
            this.clicked_time = 15;
            this.unclicked = 0;
            this.click_x = mouse_x;
            this.click_y = mouse_y;
        );
        
        // sets await for second click after picking up mouse
        // also allows knob to be dragged again after reset
        mouse_cap == 0 ? (
            this.unclicked = 1;
            this.reset = 0;
        );

        // resets knob to init
        // same_spot = this.click_x == mouse_x && this.click_y == mouse_y;
        sim_spot = (this.click_x - mouse_x)^2 + (this.click_y - mouse_y)^2 < 10;
        this.clicked_time > 0 && this.unclicked && mouse_cap && sim_spot ? (
            val = this.init_val;
            this.clicked_time = 0;
            this.unclicked = 0;
            this.reset_time = 10;
            this.reset = 1;
        );
        this.clicked_time = max(this.clicked_time-1, 0);
        this.reset_time = max(this.reset_time-1, 0);
        !this.clicked_time ? (this.unclicked = 0);
        
        this.reset;
    );
);

function button_update_slider() instance(slider_idx) (
    slider(slider_idx) != this.val ? (
        // sliderchange(2 ^ (slider_idx-1)); // while having this active cause weird feedback?
        slider_automate(2 ^ (slider_idx-1));
        slider(slider_idx) = this.val;
    );
);

function button_detect_slider() instance(slider_idx) (
    this.val = slider(slider_idx);
);