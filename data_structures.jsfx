desc:Data Structures

import defines.jsfx

@init
// Array-like

// Need this or just find()?
function contains(val) local(n) (
    result = 0;
    n = 0;
    loop(this.length, // use while to break early?
        this[n] == val ? result = 1;
        n += 1;
    );
    
    result;
);

function find(val) local(n) (
    result = NOT_FOUND;
    n = 0;
    loop(this.length, // use while to break early?
        this[n] == val ? result = n;
        n += 1;
    );
    
    result;
);

function push(val) (
    this[this.length] = val;
    this.length += 1;
);

function remove_at(idx) local(n, num_move) (
    num_move = this.length - idx - 1;
    n = 0;
    loop(num_move,
        this[idx + n] = this[idx + n + 1];
        n += 1;
    );
    this.length -= 1;
);

function remove(val) local(n, idx) (
    idx = this.find(val);
    !(idx == NOT_FOUND) ? (
        this.remove_at(idx);
    );
);

function sort() local(sorted, n, temp, flips) (
    sorted = this.length < 2;
    while (!sorted) (
        flips = 0;
        n = 0;
        loop(this.length-1,
            this[n] > this[n+1] ? (
                temp = this[n+1];
                this[n+1] = this[n];
                this[n] = temp;
                flips += 1;
            );
            n += 1;
        );
        sorted = flips == 0;
    );
);

// Avoid copy past here?
function min() local(x, n) (
    x = this[0];
    n = 1;
    loop(this.length-1,
        this[n] < x ? (
            x = this[n];
        );
        n += 1;
    );

    x;
);
function max() local(x, n) (
    x = this[0];
    n = 1;
    loop(this.length-1,
        this[n] > x ? (
            x = this[n];
        );
        n += 1;
    );

    x;
);

function end() (
    this + max(this.length - 1, 0);
);

function clear() (
    this.length = 0;
);

// Alternative to using this is just to keep a sorted version that we generate
// during the MIDI receive block
// Be careful since this is not thread-safe with respect to `this`
// This is a bit complicated
function find_next_cyclic(val, direction) local(n, ret, idx, found) (
    n = 0;
    potential_next = this.end() + 1; // align memory to just after `this`

    loop(this.length,
        found = direction == FORWARD ? this[n] > val : this[n] < val;
        found ? (
            potential_next.push(this[n]);
        );
        n += 1;
    );

    direction == FORWARD ? (
        ret = potential_next.length == 0 ? this.min() : potential_next.min();
    ) : (
        ret = potential_next.length == 0 ? this.max() : potential_next.max();
    );
    potential_next.clear();

    ret;
);